{"喜欢": {"526782d548ed01b7c09009216a66c9a7": {"id": "526782d548ed01b7c09009216a66c9a7", "item": "喜欢", "title": "我的祖国啊", "date": "2020-10-21", "summary": "我希望我的爱情是这样的，相濡以沫，举案齐眉，平淡如水。我在岁月中找到他，依靠他，将一生交付给他。做他的妻子，他孩子的母亲，为他做饭，洗衣服，缝一颗掉了的纽扣。然后，我们一起在时光中变老。", "body": "----------------------------------------------------------------------------------------\n\n\n茫茫人海里遇见一个人有多难？有时候很难，几十亿人，一生也难见一次。有时却很容易，人群中第一眼就能把他认出来。我们总在不设防的时候喜欢上一些人。没什么原因，也许只是一个温和的笑容，一句关切的问候。可能未曾谋面，可能志趣并不相投，可能不在一个高度，却牢牢地放在心上了。冥冥中该来则来，无处可逃，就好像喜欢一首歌，往往就因为一个旋律或一句打动你的歌词。喜欢或者讨厌，是让人莫名其妙的事情。\naaaaa\n居中的图片: ![Alt](/assets/images/03.jpg)\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "03.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}, "随笔": {"098f6bcd4621d373cade4e832627b4f6": {"id": "098f6bcd4621d373cade4e832627b4f6", "item": "随笔", "title": "现在，我相信爱情！", "date": "2020-09-29", "summary": "我希望我的爱情是这样的，相濡以沫，举案齐眉，平淡如水。我在岁月中找到他，依靠他，将一生交付给他。做他的妻子，他孩子的母亲，为他做饭，洗衣服，缝一颗掉了的纽扣。然后，我们一起在时光中变老。", "body": "------------------------------------------------------------------------------\n\n\n茫茫人海里遇见一个人有多难？有时候很难，几十亿人，一生也难见一次。有时却很容易，人群中第一眼就能把他认出来。我们总在不设防的时候喜欢上一些人。没什么原因，也许只是一个温和的笑容，一句关切的问候。可能未曾谋面，可能志趣并不相投，可能不在一个高度，却牢牢地放在心上了。冥冥中该来则来，无处可逃，就好像喜欢一首歌，往往就因为一个旋律或一句打动你的歌词。喜欢或者讨厌，是让人莫名其妙的事情。\n\n测试aaaabbbbb\n居中的图片: ![Alt](/assets/images/03.jpg)\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "03.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "7f0200414d943bbce847db92a77d9db1": {"id": "7f0200414d943bbce847db92a77d9db1", "item": "随笔", "title": "你是睡美人还是在等待戈多", "date": "2020-09-29", "summary": "睡美人与等待戈多的故事，你听过吗？世间有两种人在等待，一种是睡美人，另一种是戈多。你是睡美人还是在等待戈多？睡美人是那种知道自己想要什么，却不去行动，只会等待机会的人。睡等王子来唤醒，来垂青。戈多则是压根不知道自己想要什么，只是按照惯性活着，一年一年又一年。", "body": "\n睡美人与等待戈多的故事，你听过吗？\n\n世间有两种人在等待，一种是睡美人，另一种是戈多。\n\n ![img](https://img-blog.csdnimg.cn/20190813134953786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n你是睡美人还是在等待戈多？\n\n睡美人是那种知道自己想要什么，**却不去行动，只会等待机会的人**。睡等王子来唤醒，来垂青。\n\n戈多则是压根不知道自己想要什么，只是**按照惯性活着，一年一年又一年**。\n\n日复一日的重复，直到白了头发，老了容颜。没有意义的轮回，平淡一生。\n\n ![img](https://img-blog.csdnimg.cn/20190813135258338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n**等待，永远没有未来**。\n\n**只有做，才会改变当下的窘境**。\n\n很显然，睡美人或等待戈多，是绝大多数人之所以终其一生都不曾有过什么改变的原因。\n\n因为**做，才会改变**。\n\n做，才能改变！\n\n ![img](https://img-blog.csdnimg.cn/20190813093728196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n先不管结果。\n\n**用心去做一件事**的样子很迷人。应该找一件事并用心去做，至少不会是浑浑噩噩！\n\n如果只把做看做忙碌的话，那没有人没在做了。\n\n根据生活惯性去做的，不加思考的，只是一种被动的机械性，重复性。\n\n没有自主意识，当然不会看见希望，也不会有改变。\n\n甚至称不上是在做，只能算是**按惯性活着**。\n\n**如果想要你不曾拥有过的东西，就必须去做你从未做过的事情**。\n\n哪怕是出一趟远门，或走一条陌生的小路。\n\n**不同的选择，不同的路**。\n\n**不同的路，不同的景**。\n\n**不同的景，不同的人生**。\n\n做、才能改变，敢不敢为理想决绝一点儿。\n\n做，**贵在坚持**。\n\n这世上什么最难？\n\n坚持最难，十年磨一剑的坚持。最难，也最可贵。\n\n如果把人生比作一场马拉松比赛，很多人不是输在了起跑线，而是**输在了中途的坚持**。\n\n人，短暂的几十年寿命，匆匆而已。\n\n不想着变就真的老了。\n\n生命就会是条直线，毫无色彩和回忆可言。\n\n ![img](https://img-blog.csdnimg.cn/20190813093700249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n观看电影《再见路星河》有感，“笑容”，“眼泪”，“得意”，“羞涩”，我们。\n\n**即便没人为我们喝彩，我们也要活出生命的精彩**！人海之中，喧哗至上––《再见路星河》\n\n ![img](https://img-blog.csdnimg.cn/20190813103950923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n推荐看一看《再见路星河》，一群年经人的青春岁月与激情澎湃。\n\n**敢不敢很努力、很认真的做一件事，做成一件事**。\n\n人要有上进心，**积极进取**！\n\n不管结果如何，\n\n实践的过程是**充实的**、\n\n实践的过程是**美丽的**、\n\n实践的过程是**值得回忆的**！\n\n ![img](https://img-blog.csdnimg.cn/20190813112639392.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODg2NA==,size_16,color_FFFFFF,t_70) \n\n成功不是追求别人眼中的最好，而是**把自己的事情做得最好**。\n\n贵在坚持，难在坚持！\n\n维克多的四种特质：\n\n一，**自信心**。\n\n二，拥有**学习的动力和决心**。\n\n三，有**独立的判断和思考能力**。\n\n四，**热爱自己的工作**。\n\n![1591836337992](/assets/images/me1.jpg)", "imgFile": "s3.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "30806a8afedd87abecf1f91cb39c1a6c": {"id": "30806a8afedd87abecf1f91cb39c1a6c", "item": "随笔", "title": "现在，我相信爱情！", "date": "2020-09-21", "summary": "我希望我的爱情是这样的，相濡以沫，举案齐眉，平淡如水。我在岁月中找到他，依靠他，将一生交付给他。做他的妻子，他孩子的母亲，为他做饭，洗衣服，缝一颗掉了的纽扣。然后，我们一起在时光中变老。", "body": "----------------------------------------------------------------------------------------\n\n\n茫茫人海里遇见一个人有多难？有时候很难，几十亿人，一生也难见一次。有时却很容易，人群中第一眼就能把他认出来。我们总在不设防的时候喜欢上一些人。没什么原因，也许只是一个温和的笑容，一句关切的问候。可能未曾谋面，可能志趣并不相投，可能不在一个高度，却牢牢地放在心上了。冥冥中该来则来，无处可逃，就好像喜欢一首歌，往往就因为一个旋律或一句打动你的歌词。喜欢或者讨厌，是让人莫名其妙的事情。\n\naaa\n\n居中的图片: ![Alt](/assets/images/03.jpg)\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "03.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}, "常用工具": {"411eaaaa405899304e54dce3363a2baf": {"id": "411eaaaa405899304e54dce3363a2baf", "item": "常用工具", "title": "Typora的使用", "date": "2020-09-29", "summary": "Thank you for choosing Typora. This document will help you to start Typora. Please note that Typora for Windows is still in beta phase, so this document may be updated in future version-ups.", "body": "\n# Welcome\n\nThank you for choosing **Typora**. This document will help you to start Typora. Please note that Typora for Windows is still in beta phase, so this document may be updated in future version-ups.\n\n[TOC]\n\n## Live Preview\n\n**Typora** use the feature: *Live Preview*, meaning that you could see these inline styles after you finish typing, and see block styles when you type or after you press `Enter` key or focus to another paragraph. Just try to type some markdown in typora, and you would see how it works.\n\n**Note**: Markdown tags for inline styles, such as `**` will be hidden or displayed smartly. Markdown tags for block level styles, such as `###` or `- [x]` will be hidden once the block is rendered.\n\nYou could switch to source code mode temporary from menu bar, footer bar or short cut key (`ctrl+/`). But we only provide very basic support for source code mode and won't recommend users to do so.\n\n## Markdown For Typora\n\n**Typora** is using [GitHub Flavored Markdown](https://help.github.com/articles/github-flavored-markdown/) . \n\nTo see full markdown Syntax references and extra usage, please check `Help`->`Markdown Reference` in menu bar or `About` panel. \n\n## Shortcut Keys\n\nYou could find shortcut keys in the right side of menu items from menu bar. For custom shortcut keys, please refer [here](Custom-Key-Binding/).\n\n## Copy\n\nWe create typora and want to make it your default markdown editor, thus copy and paste means copy from another app or paste to another app, instead of *copy/paste from/to another markdown editor*. Therefore, by default, `Copy` means `Copy As HTML` ( and `Paste` means `Paste from HTML`). \n\nHowever, after click \"**Copy Markdown source by default**\", typora will copy selected text in HTML/markdown format (When pasting, rich editors will accept the HTML format, while plain text / code editor will accept the markdown source code format).\n\nTo **copy Markdown source code** explicitly, please use shortcut key `shift+cmd+c` or `Copy as Markdown` from menu. To **Copy as HTML Code**, please select `Copy as HTML Code` from menu.\n\n## Smart Paste\n\n**Typora** is able to analyze styles of the text content in your clipboard when pasting. For example, after pasting a `<h1>HEADING</h1>` from some website, typora will keep the 'first level heading’ format instead of paste ‘heading’ as plain text. \n\nTo **paste as markdown source** or plain text, you should use `paste as plain text` or press the shortcut key: `shift+cmd+v`.\n\n## Themes\n\nPlease refer to `Help` → `Custom Themes` from menu bar.\n\n## Publish\n\nCurrently Typora only support to export as **PDF** or **HTML**. More data format support as import/export will be integrated in future.\n\n## Auto Save and File Recovery\n\nTypora support  auto save feature, user could enable it from preference panel. \n\nTypora does not provide professional version control and file backup feature, but typora would backup the last file content from time to time automatically, so even when typora crashes or users forget to save the file before close, it is possible to recovery most of the work by clicking `Recovery Unsaved Drafts` from preference folder, and copy out backed-up files. The File name in this folder is consists of last saved date, originally file name and last saved timestamp.\n\n## More Useful Tips & Documents\n\n<http://support.typora.io/>\n\n## And More ?\n\nFor more questions or feedbacks, please contact us by:\n\n- Home Page: http://typora.io\n- Email: <hi@typora.io>\n- Twitter [@typora](https://twitter.com/typora)\n\nWe opened a Github issue page in case you want to start a discussion or as an alternative way to report bugs/suggestions: https://github.com/typora/typora-issues/issues", "imgFile": "03.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}, "联想": {"ad0234829205b9033196ba818f7a872b": {"id": "ad0234829205b9033196ba818f7a872b", "item": "联想", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}, "go学习笔记": {"3eaf98ad2b949b3f93d16aeaa1f45ab0": {"id": "3eaf98ad2b949b3f93d16aeaa1f45ab0", "item": "go学习笔记", "title": "go语言文件目录监控功能", "date": "2020-10-23", "summary": "watcher is a Go package for watching for files or directory changes (recursively or non recursively) without using filesystem events, which allows it to work cross platform consistently.", "body": "\n# watcher\n## TODO  \n\n### command line  \n\n- [ ] initiate  \n- [ ] participate  \n- [ ] redeem  \n- [ ] refund  \n\n### doc  \n- [x] ReadMe\n- [ ] ReadMe_CN\n\n:angry:\n:smile:\n:laughing:\n:sunny:\n:blush:\n:pig:\n\n> aaaaaaaaa\n\n* * *\n\n::: warning\n*here be dragons*\n:::\n\n\nHere is a footnote reference,[^1] and another.[^longnote]\n\n[^1]: Here is the footnote.\n\n[^longnote]: Here's one with multiple blocks.\n\n    Subsequent paragraphs are indented to show that they\nbelong to the previous footnote.\n\n::: warning\n*here be dragons*\n:::\n\n\n\n>这是一段包含**加粗**的 _斜体_ 和 _**斜粗体**_ 并带有`高亮`显示的一段文本来自[我的Github](https://github.com/SeayXu \"SeayXu\")。\n我是图片：\n![github logo][github-img]\n[github-url]:https://github.com/SeayXu \"SeayXu\"\n\n[![Build Status](https://travis-ci.org/radovskyb/watcher.svg?branch=master)](https://travis-ci.org/radovskyb/watcher)\n\n`watcher` is a Go package for watching for files or directory changes (recursively or non recursively) without using filesystem events, which allows it to work cross platform consistently.\n\n`watcher` watches for changes and notifies over channels either anytime an event or an error has occurred.\n\nEvents contain the `os.FileInfo` of the file or directory that the event is based on and the type of event and file or directory path.\n\n[Installation](#installation)  \n[Features](#features)  \n[Example](#example)  \n[Contributing](#contributing)  \n[Watcher Command](#command)  \n\n# Update\n- Event.OldPath has been added [Aug 17, 2019]\n- Added new file filter hooks (Including a built in regexp filtering hook) [Dec 12, 2018]\n- Event.Path for Rename and Move events is now returned in the format of `fromPath -> toPath`\n\n#### Chmod event is not supported under windows.\n\n# Installation\n\n```shell\ngo get -u github.com/radovskyb/watcher/...\n```\n\n# Features\n\n- Customizable polling interval.\n- Filter Events.\n- Watch folders recursively or non-recursively.\n- Choose to ignore hidden files.\n- Choose to ignore specified files and folders.\n- Notifies the `os.FileInfo` of the file that the event is based on. e.g `Name`, `ModTime`, `IsDir`, etc.\n- Notifies the full path of the file that the event is based on or the old and new paths if the event was a `Rename` or `Move` event.\n- Limit amount of events that can be received per watching cycle.\n- List the files being watched.\n- Trigger custom events.\n\n# Todo\n\n- Write more tests.\n- Write benchmarks.\n\n# Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/radovskyb/watcher\"\n)\n\nfunc main() {\n\tw := watcher.New()\n\n\t// SetMaxEvents to 1 to allow at most 1 event's to be received\n\t// on the Event channel per watching cycle.\n\t//\n\t// If SetMaxEvents is not set, the default is to send all events.\n\tw.SetMaxEvents(1)\n\n\t// Only notify rename and move events.\n\tw.FilterOps(watcher.Rename, watcher.Move)\n\n\t// Only files that match the regular expression during file listings\n\t// will be watched.\n\tr := regexp.MustCompile(\"^abc$\")\n\tw.AddFilterHook(watcher.RegexFilterHook(r, false))\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event := <-w.Event:\t\n\t\t\t\tfmt.Println(event) // Print the event's info.\n\t\t\tcase err := <-w.Error:\n\t\t\t\tlog.Fatalln(err)\n\t\t\tcase <-w.Closed:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Watch this folder for changes.\n\tif err := w.Add(\".\"); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// Watch test_folder recursively for changes.\n\tif err := w.AddRecursive(\"../test_folder\"); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n\n\t// Print a list of all of the files and folders currently\n\t// being watched and their paths.\n\tfor path, f := range w.WatchedFiles() {\n\t\tfmt.Printf(\"%s: %s\\n\", path, f.Name())\n\t}\n\n\tfmt.Println()\n\n\t// Trigger 2 events after watcher started.\n\tgo func() {\n\t\tw.Wait()\n\t\tw.TriggerEvent(watcher.Create, nil)\n\t\tw.TriggerEvent(watcher.Remove, nil)\n\t}()\n\n\t// Start the watching process - it'll check for changes every 100ms.\n\tif err := w.Start(time.Millisecond * 100); err != nil {\n\t\tlog.Fatalln(err)\n\t}\n}\n```\n\n# Contributing\nIf you would ike to contribute, simply submit a pull request.\n\n# Command\n\n`watcher` comes with a simple command which is installed when using the `go get` command from above.\n\n# Usage\n\n```\nUsage of watcher:\n  -cmd string\n    \tcommand to run when an event occurs\n  -dotfiles\n    \twatch dot files (default true)\n  -ignore string\n        comma separated list of paths to ignore\n  -interval string\n    \twatcher poll interval (default \"100ms\")\n  -keepalive\n    \tkeep alive when a cmd returns code != 0\n  -list\n    \tlist watched files on start\n  -pipe\n    \tpipe event's info to command's stdin\n  -recursive\n    \twatch folders recursively (default true)\n  -startcmd\n    \trun the command when watcher starts\n```\n\nAll of the flags are optional and watcher can also be called by itself:\n```shell\nwatcher\n```\n(watches the current directory recursively for changes and notifies any events that occur.)\n\nA more elaborate example using the `watcher` command:\n```shell\nwatcher -dotfiles=false -recursive=false -cmd=\"./myscript\" main.go ../\n```\nIn this example, `watcher` will ignore dot files and folders and won't watch any of the specified folders recursively. It will also run the script `./myscript` anytime an event occurs while watching `main.go` or any files or folders in the previous directory (`../`).\n\nUsing the `pipe` and `cmd` flags together will send the event's info to the command's stdin when changes are detected.\n\nFirst create a file called `script.py` with the following contents:\n```python\nimport sys\n\nfor line in sys.stdin:\n\tprint (line + \" - python\")\n```\n\nNext, start watcher with the `pipe` and `cmd` flags enabled:\n```shell\nwatcher -cmd=\"python script.py\" -pipe=true\n```\n\nNow when changes are detected, the event's info will be output from the running python script.\n", "imgFile": "09.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "c8564666fce10414f998096de1cfb647": {"id": "c8564666fce10414f998096de1cfb647", "item": "go学习笔记", "title": "﻿upx工具的使用,神器", "date": "2020-10-22", "summary": "嫌go编译后的动态库或静态库供c代码或嵌入式终端使用，体积太大？upx工具解决这一问题。", "body": "\n\n1.go build添加 -ldflags=\"-w -s\"  会去除 DWARF调试信息、符号信息\n\n```\ngo build -ldflags=\"-w -s\" ota_main.go\n```\n\n```\ngo build -buildmode=c-shared -o test.so\n```\n-buildmode=c-shared requires exactly one main package\n\n注意：生成C可调用的so时，Go源代码需要以下几个注意。\n\n必须导入 “C” 包\n\n必须在可外部调用的函数前加上 【//export 函数名】的注释\n\n必须是main包，切含有main函数，main函数可以什么都不干\n\n2.优化方案 第二步：压缩优化\n\n执行命令：\n```\nupx.exe -9 *.exe\n```\nupx-3.96-amd64_linux.tar.xz\n\n打开文件夹\n\nupx工具  解压后放到  /usr/bin目录下就可以直接使用了\n\n编译为c动态库用的什么指令？\n\n增加一个属性：-buildmode=c-archive\n\n-buildmode=c-shared     这个是动态库\n\n举例：一个go文件编译初始值：7M\n\n去调试信息编译：5.2M\n\nupx处理后：1.9M\n\n![1591950391216](/assets/images/20200612001.png)\n\n\n\n![1591950422283](/assets/images/20200612002.png)\n\n\n\n![1591950469875](/assets/images/20200612003.png)\n\nNAME\n    upx - compress or expand executable files\n\nSYNOPSIS\n    upx [ *command* ] [ *options* ] *filename*...\n\nABSTRACT\n                        The Ultimate Packer for eXecutables\n       Copyright (c) 1996-2020 Markus Oberhumer, Laszlo Molnar & John Reiser\n                               https://upx.github.io\n\n    UPX is a portable, extendable, high-performance executable packer for\n    several different executable formats. It achieves an excellent\n    compression ratio and offers **very** fast decompression. Your\n    executables suffer no memory overhead or other drawbacks for most of the\n    formats supported, because of in-place decompression.\n    \n    While you may use UPX freely for both non-commercial and commercial\n    executables (for details see the file LICENSE), we would highly\n    appreciate if you credit UPX and ourselves in the documentation,\n    possibly including a reference to the UPX home page. Thanks.\n    \n    [ Using UPX in non-OpenSource applications without proper credits is\n    considered not politically correct ;-) ]\n\nDISCLAIMER\n    UPX comes with ABSOLUTELY NO WARRANTY; for details see the file LICENSE.\n\n    This is the first production quality release, and we plan that future\n    1.xx releases will be backward compatible with this version.\n    \n    Please report all problems or suggestions to the authors. Thanks.\n\nDESCRIPTION\n    UPX is a versatile executable packer with the following features:\n\n      - excellent compression ratio: compresses better than zip/gzip,\n          use UPX to decrease the size of your distribution !\n    \n      - very fast decompression: about 10 MiB/sec on an ancient Pentium 133,\n          about 200 MiB/sec on an Athlon XP 2000+.\n    \n      - no memory overhead for your compressed executables for most of the\n          supported formats\n    \n      - safe: you can list, test and unpack your executables\n          Also, a checksum of both the compressed and uncompressed file is\n          maintained internally.\n    \n      - universal: UPX can pack a number of executable formats:\n          * atari/tos\n          * bvmlinuz/386    [bootable Linux kernel]\n          * djgpp2/coff\n          * dos/com\n          * dos/exe\n          * dos/sys\n          * linux/386\n          * linux/elf386\n          * linux/sh386\n          * ps1/exe\n          * rtm32/pe\n          * tmt/adam\n          * vmlinuz/386     [bootable Linux kernel]\n          * vmlinux/386\n          * watcom/le (supporting DOS4G, PMODE/W, DOS32a and CauseWay)\n          * win32/pe (exe and dll)\n          * win64/pe (exe and dll)\n          * arm/pe (exe and dll)\n          * linux/elfamd64\n          * linux/elfppc32\n          * mach/elfppc32\n    \n      - portable: UPX is written in portable endian-neutral C++\n    \n      - extendable: because of the class layout it's very easy to support\n          new executable formats or add new compression algorithms\n    \n      - free: UPX can be distributed and used freely. And from version 0.99\n          the full source code of UPX is released under the GNU General Public\n          License (GPL) !\n    \n    You probably understand now why we call UPX the \"*ultimate*\" executable\n    packer.\n\nCOMMANDS\n  Compress\n    This is the default operation, eg. upx yourfile.exe will compress the\n    file specified on the command line.\n\n  Decompress\n    All UPX supported file formats can be unpacked using the -d switch, eg.\n    upx -d yourfile.exe will uncompress the file you've just compressed.\n\n  Test\n    The -t command tests the integrity of the compressed and uncompressed\n    data, eg. upx -t yourfile.exe check whether your file can be safely\n    decompressed. Note, that this command doesn't check the whole file, only\n    the part that will be uncompressed during program execution. This means\n    that you should not use this command instead of a virus checker.\n\n  List\n    The -l command prints out some information about the compressed files\n    specified on the command line as parameters, eg upx -l yourfile.exe\n    shows the compressed / uncompressed size and the compression ratio of\n    *yourfile.exe*.\n\nOPTIONS\n    -q: be quiet, suppress warnings\n\n    -q -q (or -qq): be very quiet, suppress errors\n    \n    -q -q -q (or -qqq): produce no output at all\n    \n    --help: prints the help\n    \n    --version: print the version of UPX\n    \n    --exact: when compressing, require to be able to get a byte-identical\n    file after decompression with option -d. [NOTE: this is work in progress\n    and is not supported for all formats yet. If you do care, as a\n    workaround you can compress and then decompress your program a first\n    time - any further compress-decompress steps should then yield\n    byte-identical results as compared to the first decompressed version.]\n    \n    [ ...to be written... - type `upx --help' for now ]\n\nCOMPRESSION LEVELS & TUNING\n    UPX offers ten different compression levels from -1 to -9, and --best.\n    The default compression level is -8 for files smaller than 512 KiB, and\n    -7 otherwise.\n\n    *   Compression levels 1, 2 and 3 are pretty fast.\n    \n    *   Compression levels 4, 5 and 6 achieve a good time/ratio performance.\n    \n    *   Compression levels 7, 8 and 9 favor compression ratio over speed.\n    \n    *   Compression level --best may take a long time.\n    \n    Note that compression level --best can be somewhat slow for large files,\n    but you definitely should use it when releasing a final version of your\n    program.\n    \n    Quick info for achieving the best compression ratio:\n    \n    *   Try upx --brute myfile.exe or even upx --ultra-brute myfile.exe.\n    \n    *   Try if --overlay=strip works.\n    \n    *   For win32/pe programs there's --strip-relocs=0. See notes below.\n\nOVERLAY HANDLING OPTIONS\n    Info: An \"overlay\" means auxiliary data attached after the logical end\n    of an executable, and it often contains application specific data (this\n    is a common practice to avoid an extra data file, though it would be\n    better to use resource sections).\n\n    UPX handles overlays like many other executable packers do: it simply\n    copies the overlay after the compressed image. This works with some\n    files, but doesn't work with others, depending on how an application\n    actually accesses this overlayed data.\n    \n      --overlay=copy    Copy any extra data attached to the file. [DEFAULT]\n    \n      --overlay=strip   Strip any overlay from the program instead of\n                        copying it. Be warned, this may make the compressed\n                        program crash or otherwise unusable.\n    \n      --overlay=skip    Refuse to compress any program which has an overlay.\n\nENVIRONMENT\n    The environment variable UPX can hold a set of default options for UPX.\n    These options are interpreted first and can be overwritten by explicit\n    command line parameters. For example:\n\n        for DOS/Windows:   set UPX=-9 --compress-icons#0\n        for sh/ksh/zsh:    UPX=\"-9 --compress-icons=0\"; export UPX\n        for csh/tcsh:      setenv UPX \"-9 --compress-icons=0\"\n    \n    Under DOS/Windows you must use '#' instead of '=' when setting the\n    environment variable because of a COMMAND.COM limitation.\n    \n    Not all of the options are valid in the environment variable - UPX will\n    tell you.\n    \n    You can explicitly use the --no-env option to ignore the environment\n    variable.\n\nNOTES FOR THE SUPPORTED EXECUTABLE FORMATS\n  NOTES FOR ATARI/TOS\n    This is the executable format used by the Atari ST/TT, a Motorola 68000\n    based personal computer which was popular in the late '80s. Support of\n    this format is only because of nostalgic feelings of one of the authors\n    and serves no practical purpose :-). See http://www.freemint.de for more\n    info.\n\n    Packed programs will be byte-identical to the original after\n    uncompression. All debug information will be stripped, though.\n    \n    Extra options available for this executable format:\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n\n  NOTES FOR BVMLINUZ/I386\n    Same as vmlinuz/i386.\n\n  NOTES FOR DOS/COM\n    Obviously UPX won't work with executables that want to read data from\n    themselves (like some commandline utilities that ship with Win95/98/ME).\n\n    Compressed programs only work on a 286+.\n    \n    Packed programs will be byte-identical to the original after\n    uncompression.\n    \n    Maximum uncompressed size: ~65100 bytes.\n    \n    Extra options available for this executable format:\n    \n      --8086              Create an executable that works on any 8086 CPU.\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\n  NOTES FOR DOS/EXE\n    dos/exe stands for all \"normal\" 16-bit DOS executables.\n\n    Obviously UPX won't work with executables that want to read data from\n    themselves (like some command line utilities that ship with\n    Win95/98/ME).\n    \n    Compressed programs only work on a 286+.\n    \n    Extra options available for this executable format:\n    \n      --8086              Create an executable that works on any 8086 CPU.\n    \n      --no-reloc          Use no relocation records in the exe header.\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n\n  NOTES FOR DOS/SYS\n    Compressed programs only work on a 286+.\n\n    Packed programs will be byte-identical to the original after\n    uncompression.\n    \n    Maximum uncompressed size: ~65350 bytes.\n    \n    Extra options available for this executable format:\n    \n      --8086              Create an executable that works on any 8086 CPU.\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\n  NOTES FOR DJGPP2/COFF\n    First of all, it is recommended to use UPX *instead* of strip. strip has\n    the very bad habit of replacing your stub with its own (outdated)\n    version. Additionally UPX corrects a bug/feature in strip v2.8.x: it\n    will fix the 4 KiB alignment of the stub.\n\n    UPX includes the full functionality of stubify. This means it will\n    automatically stubify your COFF files. Use the option --coff to disable\n    this functionality (see below).\n    \n    UPX automatically handles Allegro packfiles.\n    \n    The DLM format (a rather exotic shared library extension) is not\n    supported.\n    \n    Packed programs will be byte-identical to the original after\n    uncompression. All debug information and trailing garbage will be\n    stripped, though.\n    \n    Extra options available for this executable format:\n    \n      --coff              Produce COFF output instead of EXE. By default\n                          UPX keeps your current stub.\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\n  NOTES FOR LINUX [general]\n    Introduction\n\n      Linux/386 support in UPX consists of 3 different executable formats,\n      one optimized for ELF executables (\"linux/elf386\"), one optimized\n      for shell scripts (\"linux/sh386\"), and one generic format\n      (\"linux/386\").\n    \n      We will start with a general discussion first, but please\n      also read the relevant docs for each of the individual formats.\n    \n      Also, there is special support for bootable kernels - see the\n      description of the vmlinuz/386 format.\n    \n    General user's overview\n    \n      Running a compressed executable program trades less space on a\n      ``permanent'' storage medium (such as a hard disk, floppy disk,\n      CD-ROM, flash memory, EPROM, etc.) for more space in one or more\n      ``temporary'' storage media (such as RAM, swap space, /tmp, etc.).\n      Running a compressed executable also requires some additional CPU\n      cycles to generate the compressed executable in the first place,\n      and to decompress it at each invocation.\n    \n      How much space is traded?  It depends on the executable, but many\n      programs save 30% to 50% of permanent disk space.  How much CPU\n      overhead is there?  Again, it depends on the executable, but\n      decompression speed generally is at least many megabytes per second,\n      and frequently is limited by the speed of the underlying disk\n      or network I/O.\n    \n      Depending on the statistics of usage and access, and the relative\n      speeds of CPU, RAM, swap space, /tmp, and file system storage, then\n      invoking and running a compressed executable can be faster than\n      directly running the corresponding uncompressed program.\n      The operating system might perform fewer expensive I/O operations\n      to invoke the compressed program.  Paging to or from swap space\n      or /tmp might be faster than paging from the general file system.\n      ``Medium-sized'' programs which access about 1/3 to 1/2 of their\n      stored program bytes can do particularly well with compression.\n      Small programs tend not to benefit as much because the absolute\n      savings is less.  Big programs tend not to benefit proportionally\n      because each invocation may use only a small fraction of the program,\n      yet UPX decompresses the entire program before invoking it.\n      But in environments where disk or flash memory storage is limited,\n      then compression may win anyway.\n    \n      Currently, executables compressed by UPX do not share RAM at runtime\n      in the way that executables mapped from a file system do.  As a\n      result, if the same program is run simultaneously by more than one\n      process, then using the compressed version will require more RAM and/or\n      swap space.  So, shell programs (bash, csh, etc.)  and ``make''\n      might not be good candidates for compression.\n    \n      UPX recognizes three executable formats for Linux: Linux/elf386,\n      Linux/sh386, and Linux/386.  Linux/386 is the most generic format;\n      it accommodates any file that can be executed.  At runtime, the UPX\n      decompression stub re-creates in /tmp a copy of the original file,\n      and then the copy is (re-)executed with the same arguments.\n      ELF binary executables prefer the Linux/elf386 format by default,\n      because UPX decompresses them directly into RAM, uses only one\n      exec, does not use space in /tmp, and does not use /proc.\n      Shell scripts where the underlying shell accepts a ``-c'' argument\n      can use the Linux/sh386 format.  UPX decompresses the shell script\n      into low memory, then maps the shell and passes the entire text of the\n      script as an argument with a leading ``-c''.\n    \n    General benefits:\n    \n      - UPX can compress all executables, be it AOUT, ELF, libc4, libc5,\n        libc6, Shell/Perl/Python/... scripts, standalone Java .class\n        binaries, or whatever...\n        All scripts and programs will work just as before.\n    \n      - Compressed programs are completely self-contained. No need for\n        any external program.\n    \n      - UPX keeps your original program untouched. This means that\n        after decompression you will have a byte-identical version,\n        and you can use UPX as a file compressor just like gzip.\n        [ Note that UPX maintains a checksum of the file internally,\n          so it is indeed a reliable alternative. ]\n    \n      - As the stub only uses syscalls and isn't linked against libc it\n        should run under any Linux configuration that can run ELF\n        binaries.\n    \n      - For the same reason compressed executables should run under\n        FreeBSD and other systems which can run Linux binaries.\n        [ Please send feedback on this topic ]\n    \n    General drawbacks:\n    \n      - It is not advisable to compress programs which usually have many\n        instances running (like `sh' or `make') because the common segments of\n        compressed programs won't be shared any longer between different\n        processes.\n    \n      - `ldd' and `size' won't show anything useful because all they\n        see is the statically linked stub.  Since version 0.82 the section\n        headers are stripped from the UPX stub and `size' doesn't even\n        recognize the file format.  The file patches/patch-elfcode.h has a\n        patch to fix this bug in `size' and other programs which use GNU BFD.\n    \n    General notes:\n    \n      - As UPX leaves your original program untouched it is advantageous\n        to strip it before compression.\n    \n      - If you compress a script you will lose platform independence -\n        this could be a problem if you are using NFS mounted disks.\n    \n      - Compression of suid, guid and sticky-bit programs is rejected\n        because of possible security implications.\n    \n      - For the same reason there is no sense in making any compressed\n        program suid.\n    \n      - Obviously UPX won't work with executables that want to read data\n        from themselves. E.g., this might be a problem for Perl scripts\n        which access their __DATA__ lines.\n    \n      - In case of internal errors the stub will abort with exitcode 127.\n        Typical reasons for this to happen are that the program has somehow\n        been modified after compression.\n        Running `strace -o strace.log compressed_file' will tell you more.\n\n  NOTES FOR LINUX/ELF386\n    Please read the general Linux description first.\n\n    The linux/elf386 format decompresses directly into RAM, uses only one\n    exec, does not use space in /tmp, and does not use /proc.\n    \n    Linux/elf386 is automatically selected for Linux ELF executables.\n    \n    Packed programs will be byte-identical to the original after\n    uncompression.\n    \n    How it works:\n    \n      For ELF executables, UPX decompresses directly to memory, simulating\n      the mapping that the operating system kernel uses during exec(),\n      including the PT_INTERP program interpreter (if any).\n      The brk() is set by a special PT_LOAD segment in the compressed\n      executable itself.  UPX then wipes the stack clean except for\n      arguments, environment variables, and Elf_auxv entries (this is\n      required by bugs in the startup code of /lib/ld-linux.so as of\n      May 2000), and transfers control to the program interpreter or\n      the e_entry address of the original executable.\n    \n      The UPX stub is about 1700 bytes long, partly written in assembler\n      and only uses kernel syscalls. It is not linked against any libc.\n    \n    Specific drawbacks:\n    \n      - For linux/elf386 and linux/sh386 formats, you will be relying on\n        RAM and swap space to hold all of the decompressed program during\n        the lifetime of the process.  If you already use most of your swap\n        space, then you may run out.  A system that is \"out of memory\"\n        can become fragile.  Many programs do not react gracefully when\n        malloc() returns 0.  With newer Linux kernels, the kernel\n        may decide to kill some processes to regain memory, and you\n        may not like the kernel's choice of which to kill.  Running\n        /usr/bin/top is one way to check on the usage of swap space.\n    \n    Extra options available for this executable format:\n    \n      (none)\n\n  NOTES FOR LINUX/SH386\n    Please read the general Linux description first.\n\n    Shell scripts where the underling shell accepts a ``-c'' argument can\n    use the Linux/sh386 format. UPX decompresses the shell script into low\n    memory, then maps the shell and passes the entire text of the script as\n    an argument with a leading ``-c''. It does not use space in /tmp, and\n    does not use /proc.\n    \n    Linux/sh386 is automatically selected for shell scripts that use a known\n    shell.\n    \n    Packed programs will be byte-identical to the original after\n    uncompression.\n    \n    How it works:\n    \n      For shell script executables (files beginning with \"#!/\" or \"#! /\")\n      where the shell is known to accept \"-c <command>\", UPX decompresses\n      the file into low memory, then maps the shell (and its PT_INTERP),\n      and passes control to the shell with the entire decompressed file\n      as the argument after \"-c\".  Known shells are sh, ash, bash, bsh, csh,\n      ksh, tcsh, pdksh.  Restriction: UPX cannot use this method\n      for shell scripts which use the one optional string argument after\n      the shell name in the script (example: \"#! /bin/sh option3\\n\".)\n    \n      The UPX stub is about 1700 bytes long, partly written in assembler\n      and only uses kernel syscalls. It is not linked against any libc.\n    \n    Specific drawbacks:\n    \n      - For linux/elf386 and linux/sh386 formats, you will be relying on\n        RAM and swap space to hold all of the decompressed program during\n        the lifetime of the process.  If you already use most of your swap\n        space, then you may run out.  A system that is \"out of memory\"\n        can become fragile.  Many programs do not react gracefully when\n        malloc() returns 0.  With newer Linux kernels, the kernel\n        may decide to kill some processes to regain memory, and you\n        may not like the kernel's choice of which to kill.  Running\n        /usr/bin/top is one way to check on the usage of swap space.\n    \n    Extra options available for this executable format:\n    \n      (none)\n\n  NOTES FOR LINUX/386\n    Please read the general Linux description first.\n\n    The generic linux/386 format decompresses to /tmp and needs /proc file\n    system support. It starts the decompressed program via the execve()\n    syscall.\n    \n    Linux/386 is only selected if the specialized linux/elf386 and\n    linux/sh386 won't recognize a file.\n    \n    Packed programs will be byte-identical to the original after\n    uncompression.\n    \n    How it works:\n    \n      For files which are not ELF and not a script for a known \"-c\" shell,\n      UPX uses kernel execve(), which first requires decompressing to a\n      temporary file in the file system.  Interestingly -\n      because of the good memory management of the Linux kernel - this\n      often does not introduce a noticeable delay, and in fact there\n      will be no disk access at all if you have enough free memory as\n      the entire process takes places within the file system buffers.\n    \n      A compressed executable consists of the UPX stub and an overlay\n      which contains the original program in a compressed form.\n    \n      The UPX stub is a statically linked ELF executable and does\n      the following at program startup:\n    \n        1) decompress the overlay to a temporary location in /tmp\n        2) open the temporary file for reading\n        3) try to delete the temporary file and start (execve)\n           the uncompressed program in /tmp using /proc/<pid>/fd/X as\n           attained by step 2)\n        4) if that fails, fork off a subprocess to clean up and\n           start the program in /tmp in the meantime\n    \n      The UPX stub is about 1700 bytes long, partly written in assembler\n      and only uses kernel syscalls. It is not linked against any libc.\n    \n    Specific drawbacks:\n    \n      - You need additional free disk space for the uncompressed program\n        in your /tmp directory. This program is deleted immediately after\n        decompression, but you still need it for the full execution time\n        of the program.\n    \n      - You must have /proc file system support as the stub wants to open\n        /proc/<pid>/exe and needs /proc/<pid>/fd/X. This also means that you\n        cannot compress programs that are used during the boot sequence\n        before /proc is mounted.\n    \n      - Utilities like `top' will display numerical values in the process\n        name field. This is because Linux computes the process name from\n        the first argument of the last execve syscall (which is typically\n        something like /proc/<pid>/fd/3).\n    \n      - Because of temporary decompression to disk the decompression speed\n        is not as fast as with the other executable formats. Still, I can see\n        no noticeable delay when starting programs like my ~3 MiB emacs (which\n        is less than 1 MiB when compressed :-).\n    \n    Extra options available for this executable format:\n    \n      --force-execve      Force the use of the generic linux/386 \"execve\"\n                          format, i.e. do not try the linux/elf386 and\n                          linux/sh386 formats.\n\n  NOTES FOR PS1/EXE\n    This is the executable format used by the Sony PlayStation (PSone), a\n    Mips R3000 based gaming console which is popular since the late '90s.\n    Support of this format is very similar to the Atari one, because of\n    nostalgic feelings of one of the authors.\n\n    Packed programs will be byte-identical to the original after\n    uncompression, until further notice.\n    \n    Maximum uncompressed size: ~1.89 / ~7.60 MiB.\n    \n    Notes:\n    \n      - UPX creates as default a suitable executable for CD-Mastering\n        and console transfer. For a CD-Master main executable you could also try\n        the special option \"--boot-only\" as described below.\n        It has been reported that upx packed executables are fully compatible with\n        the Sony PlayStation 2 (PS2, PStwo) and Sony PlayStation Portable (PSP) in\n        Sony PlayStation (PSone) emulation mode.\n    \n      - Normally the packed files use the same memory areas like the uncompressed\n        versions, so they will not override other memory areas while unpacking.\n        If this isn't possible UPX will abort showing a 'packed data overlap'\n        error. With the \"--force\" option UPX will relocate the loading address\n        for the packed file, but this isn't a real problem if it is a single or\n        the main executable.\n    \n    Extra options available for this executable format:\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --8-bit             Uses 8 bit size compression [default: 32 bit]\n    \n      --8mib-ram          PSone has 8 MiB ram available [default: 2 MiB]\n    \n      --boot-only         This format is for main exes and CD-Mastering only !\n                          It may slightly improve the compression ratio,\n                          decompression routines are faster than default ones.\n                          But it cannot be used for console transfer !\n    \n      --no-align          This option disables CD mode 2 data sector format\n                          alignment. May slightly improves the compression ratio,\n                          but the compressed executable will not boot from a CD.\n                          Use it for console transfer only !\n\n  NOTES FOR RTM32/PE and ARM/PE\n    Same as win32/pe.\n\n  NOTES FOR TMT/ADAM\n    This format is used by the TMT Pascal compiler - see http://www.tmt.com/\n    .\n\n    Extra options available for this executable format:\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\n  NOTES FOR VMLINUZ/386\n    The vmlinuz/386 and bvmlinuz/386 formats take a gzip-compressed bootable\n    Linux kernel image (\"vmlinuz\", \"zImage\", \"bzImage\"), gzip-decompress it\n    and re-compress it with the UPX compression method.\n\n    vmlinuz/386 is completely unrelated to the other Linux executable\n    formats, and it does not share any of their drawbacks.\n    \n    Notes:\n    \n      - Be sure that \"vmlinuz/386\" or \"bvmlinuz/386\" is displayed\n      during compression - otherwise a wrong executable format\n      may have been used, and the kernel won't boot.\n    \n    Benefits:\n    \n      - Better compression (but note that the kernel was already compressed,\n      so the improvement is not as large as with other formats).\n      Still, the bytes saved may be essential for special needs like\n      boot disks.\n    \n         For example, this is what I get for my 2.2.16 kernel:\n            1589708  vmlinux\n             641073  bzImage        [original]\n             560755  bzImage.upx    [compressed by \"upx -9\"]\n    \n      - Much faster decompression at kernel boot time (but kernel\n        decompression speed is not really an issue these days).\n    \n    Drawbacks:\n    \n      (none)\n    \n    Extra options available for this executable format:\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\n  NOTES FOR WATCOM/LE\n    UPX has been successfully tested with the following extenders: DOS4G,\n    DOS4GW, PMODE/W, DOS32a, CauseWay. The WDOS/X extender is partly\n    supported (for details see the file bugs BUGS).\n\n    DLLs and the LX format are not supported.\n    \n    Extra options available for this executable format:\n    \n      --le                Produce an unbound LE output instead of\n                          keeping the current stub.\n\n  NOTES FOR WIN32/PE\n    The PE support in UPX is quite stable now, but probably there are still\n    some incompatibilities with some files.\n\n    Because of the way UPX (and other packers for this format) works, you\n    can see increased memory usage of your compressed files because the\n    whole program is loaded into memory at startup. If you start several\n    instances of huge compressed programs you're wasting memory because the\n    common segments of the program won't get shared across the instances. On\n    the other hand if you're compressing only smaller programs, or running\n    only one instance of larger programs, then this penalty is smaller, but\n    it's still there.\n    \n    If you're running executables from network, then compressed programs\n    will load faster, and require less bandwidth during execution.\n    \n    DLLs are supported. But UPX compressed DLLs can not share common data\n    and code when they got used by multiple applications. So compressing\n    msvcrt.dll is a waste of memory, but compressing the dll plugins of a\n    particular application may be a better idea.\n    \n    Screensavers are supported, with the restriction that the filename must\n    end with \".scr\" (as screensavers are handled slightly different than\n    normal exe files).\n    \n    UPX compressed PE files have some minor memory overhead (usually in the\n    10 - 30 KiB range) which can be seen by specifying the \"-i\" command line\n    switch during compression.\n    \n    Extra options available for this executable format:\n    \n     --compress-exports=0 Don't compress the export section.\n                          Use this if you plan to run the compressed\n                          program under Wine.\n     --compress-exports=1 Compress the export section. [DEFAULT]\n                          Compression of the export section can improve the\n                          compression ratio quite a bit but may not work\n                          with all programs (like winword.exe).\n                          UPX never compresses the export section of a DLL\n                          regardless of this option.\n    \n      --compress-icons=0  Don't compress any icons.\n      --compress-icons=1  Compress all but the first icon.\n      --compress-icons=2  Compress all icons which are not in the\n                          first icon directory. [DEFAULT]\n      --compress-icons=3  Compress all icons.\n    \n      --compress-resources=0  Don't compress any resources at all.\n    \n      --keep-resource=list Don't compress resources specified by the list.\n                          The members of the list are separated by commas.\n                          A list member has the following format: I<type[/name]>.\n                          I<Type> is the type of the resource. Standard types\n                          must be specified as decimal numbers, user types can be\n                          specified by decimal IDs or strings. I<Name> is the\n                          identifier of the resource. It can be a decimal number\n                          or a string. For example:\n    \n                          --keep-resource=2/MYBITMAP,5,6/12345\n    \n                          UPX won't compress the named bitmap resource \"MYBITMAP\",\n                          it leaves every dialog (5) resource uncompressed, and\n                          it won't touch the string table resource with identifier\n                          12345.\n    \n      --force             Force compression even when there is an\n                          unexpected value in a header field.\n                          Use with care.\n    \n      --strip-relocs=0    Don't strip relocation records.\n      --strip-relocs=1    Strip relocation records. [DEFAULT]\n                          This option only works on executables with base\n                          address greater or equal to 0x400000. Usually the\n                          compressed files becomes smaller, but some files\n                          may become larger. Note that the resulting file will\n                          not work under Windows 3.x (Win32s).\n                          UPX never strips relocations from a DLL\n                          regardless of this option.\n    \n      --all-methods       Compress the program several times, using all\n                          available compression methods. This may improve\n                          the compression ratio in some cases, but usually\n                          the default method gives the best results anyway.\n    \n      --all-filters       Compress the program several times, using all\n                          available preprocessing filters. This may improve\n                          the compression ratio in some cases, but usually\n                          the default filter gives the best results anyway.\n\nDIAGNOSTICS\n    Exit status is normally 0; if an error occurs, exit status is 1. If a\n    warning occurs, exit status is 2.\n\n    UPX's diagnostics are intended to be self-explanatory.\n\nBUGS\n    Please report all bugs immediately to the authors.\n\nAUTHORS\n     Markus F.X.J. Oberhumer <markus@oberhumer.com>\n     http://www.oberhumer.com\n\n     Laszlo Molnar <ezerotven+github@gmail.com>\n    \n     John F. Reiser <jreiser@BitWagon.com>\n    \n     Jens Medoch <jssg@users.sourceforge.net>\n\nCOPYRIGHT\n    Copyright (C) 1996-2020 Markus Franz Xaver Johannes Oberhumer\n\n    Copyright (C) 1996-2020 Laszlo Molnar\n    \n    Copyright (C) 2000-2020 John F. Reiser\n    \n    Copyright (C) 2002-2020 Jens Medoch\n    \n    This program may be used freely, and you are welcome to redistribute it\n    under certain conditions.\n    \n    This program is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the UPX License\n    Agreement for more details.\n    \n    You should have received a copy of the UPX License Agreement along with\n    this program; see the file LICENSE. If not, visit the UPX home page.\n\n", "imgFile": "02.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}, "感悟": {"900150983cd24fb0d6963f7d28e17f72": {"id": "900150983cd24fb0d6963f7d28e17f72", "item": "感悟", "title": "Second abc!", "date": "2020-10-22", "summary": "你好aaaaaaaasssssssssssssssss！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "08.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "5a105e8b9d40e1329780d62ea2265d8a": {"id": "5a105e8b9d40e1329780d62ea2265d8a", "item": "感悟", "title": "Second post!", "date": "2020-09-09", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\naaa bbbb\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "c1a8e059bfd1e911cf10b626340c9a54": {"id": "c1a8e059bfd1e911cf10b626340c9a54", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "f696282aa4cd4f614aa995190cf442fe": {"id": "f696282aa4cd4f614aa995190cf442fe", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "60474c9c10d7142b7508ce7a50acf414": {"id": "60474c9c10d7142b7508ce7a50acf414", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "6c4e97affe728b586468f1ecd344ceb0": {"id": "6c4e97affe728b586468f1ecd344ceb0", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "c83d66a957a5806632f43661a39f930d": {"id": "c83d66a957a5806632f43661a39f930d", "item": "感悟", "title": "Second postaaaabbbbcccddeeff!", "date": "2020-10-22", "summary": "你好aaaaaaaasssssssssssssssss！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "08.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "8ad8757baa8564dc136c1e07507f4a98": {"id": "8ad8757baa8564dc136c1e07507f4a98", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "86985e105f79b95d6bc918fb45ec7727": {"id": "86985e105f79b95d6bc918fb45ec7727", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "fd196d87b9d4752fa86a3ddf1481412a": {"id": "fd196d87b9d4752fa86a3ddf1481412a", "item": "感悟", "title": "Second444 post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "e3d704f3542b44a621ebed70dc0efe13": {"id": "e3d704f3542b44a621ebed70dc0efe13", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "b04083e53e242626595e2b8ea327e525": {"id": "b04083e53e242626595e2b8ea327e525", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "5e40d09fa0529781afd1254a42913847": {"id": "5e40d09fa0529781afd1254a42913847", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "739969b53246b2c727850dbb3490ede6": {"id": "739969b53246b2c727850dbb3490ede6", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "ae2b1fca515949e5d54fb22b8ed95575": {"id": "ae2b1fca515949e5d54fb22b8ed95575", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "4c5b22f1d1840a82c4dca1e3fbe7c295": {"id": "4c5b22f1d1840a82c4dca1e3fbe7c295", "item": "感悟", "title": "从百草园到三味书屋", "date": "2020-10-24", "summary": "城市，越来越大。楼层，越盖越高。时间，越过越快。新年，越来越乏味。却逐渐少了少年时幸福的感觉。嗡嗡的拖拉机声音很少听到了，一排排整齐的麦秸垛再也不见了，村里记忆中的小河早已干枯了，回忆里泥泞的小路没有了。", "body": "\n\n城市，越来越大。楼层，越盖越高。时间，越过越快。新年，越来越乏味。\n\n却逐渐少了少年时幸福的感觉。\n\n嗡嗡的拖拉机声音很少听到了，一排排整齐的麦秸垛再也不见了，村里记忆中的小河早已干枯了，回忆里泥泞的小路没有了。\n\n村村落落整齐的水泥路，也少有了泥土的气息。\n\n很少再见到这种枯藤、老树、昏鸦，小桥、流水、人家，古道、西风、瘦马般的景象了。\n![Alt](/static/images/20200609001.png)\n\n而这种感觉，只有在下雨天静静的坐在飞速的列车上，手机也没电了，只能望着窗外碧绿的麦田，金黄的油菜花，泥泞的小路，断壁残垣的小桥，涓涓的流水才能感觉到。\n\n而这种感觉，却是大多数城里人趁着春暖花开的季节出游踏青寻绿，隐匿在心底去追寻的感觉。\n\n看着现在小孩子玩腻的玩具，游乐场玩了多少遍的滑滑梯，无聊的电视动画片（动画片里才能见到或听到的鸟叫，虫鸣，蜻蜓，蝴蝶。佩奇喜欢在泥坑里跳来跳去，而没人敢在泥坑里跳来跳去），觉得他们的童年好无趣。\n\n不知道当他们读到鲁迅的《从百草园到三味书屋》是什么感觉，但肯定不会比我们能更有体会。\n\n甚至过年过节对他们来说也没有期盼，没有意义。\n\n他们没赏过花灯、打过灯笼、放过鞭炮、点过蜡烛、贴过春联。\n\n没玩过泥巴，过过家家，捉过鱼虾，逮过蚂蚱，偷过西瓜。\n\n没观赏和体验过满天浩瀚的繁星，吴刚砍桂树的月亮，虫鸣般的夜晚，电闪雷鸣般的雨夜，清风的早晨，乘凉的大树，夏夜的凉风，清脆的鸟鸣，青蛙的歌唱。炎热的午后，吱吱的蝉声。\n\n是的科技在进步，但幸福感真的没有进步。\n![Alt](/static/images/20200609002.png)\n或许正如某人所说的，幸福如饮水，冷暖自知。\n\n幸福感跟科技进步无关，也跟拥有的多少事物不成比例。\n\n甚至有点儿成反比，拥有的越多幸福感越少很难知足。\n\n或许一个时代走一个时代的不同吧。\n\n忙碌的生活，让人们疲于奔命，却忘却了生活本来的面目。\n\n总之，生活，它是一种态度。\n\n最后，说下写作目的，想写全很难，太多了。\n\n这里只算是抛砖引玉，带领大家回忆下有趣的童年。\n\n同时引申出来一种思考，现在人们生活节奏太快了，大多数人都忙碌的生活，疲于奔命，而忘记了生活的本来面目和色彩。\n\n同时，还想表达另外一主题，乐观的面对生活吧，它的好坏取决于你的态度，在忙碌之于也要好好生活，多些家人陪伴，多注意身体。\n\n什么是最大的福？身体健康，全家人平平安安就是福。\n\n人，或许等到六十岁以后才会逐渐明白，人与人之间其实能比的，只有家人的平安健康。\n![Alt](/static/images/20200609003.png)", "imgFile": "06.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 1}, "b213d23ed7c8edd718cc2b817e0c36d5": {"id": "b213d23ed7c8edd718cc2b817e0c36d5", "item": "感悟", "title": "思考，提高效率，做更有意义的事", "date": "2020-09-09", "summary": "什么是更有意义的事？就是那些让你觉得，你愿意为此付出精力和时间，值得做的事。感兴趣的事，或者是认为有价值的事。", "body": "\n\n什么是更有意义的事？\n就是那些让你觉得，你愿意为此付出精力和时间，值得做的事，感兴趣的事，或者是认为有价值的事。\n\n但是倘若这件事并不容易，或者需要花大量的时间和精力投入，或者短时间内很难有成效？是不自然而然的就会消磨你的兴致，消磨你的毅力，可能最终会不了了之，没有收获或收获甚微。\n\n那么，有什么办法吗？才能使你觉得你做的事更有意义？\n\n习惯思考，提高效率，讲究方法，并融入自己的兴趣爱好或情怀沉下心来认真做事。\n\n一、习惯思考\n有人说这世界上有两种人，一种人是按照惯性活着，过一天是一天。根据外界的环境变化而适应着去变，去活动，也更多的是活在别人眼里。一种是主动的活着，有思考，有想法，有主见，按照自己的意愿去做事，去积极寻求改变和突破。不会人云亦云，不会随波逐流，而是特立独行的有自己的想法和意见，活在自己心中。\n其实这两种人并没有很大的区别。区别只在于，是否习惯了思考。人之所以高等在于人之有思想，有灵魂，会思考。然而会思考并不等于爱思考，人，习惯于懒惰。有时宁愿付诸体力也不去思考，因为动用体力仿佛比动脑筋来的更简单直接一些。体力纯属机械性的重复劳动，效率太低。而思考，则是效率上的提高。因此，人更应该去思考去解决问题。但不是人人都爱思考。有句话说习惯决定性格，性格决定命运。习惯是对人的一种潜移默化的约束，习惯成自然。所以让思考也应成为一种习惯。\n\n二、提高效率\n提高效率重不重要？提高效率太重要了。同样都是做一件事，如果效率不高，拖的时间太长，就会消磨你的兴致，消磨你的毅力，浪费你的时间成本。效率的提升，可以使你腾出更多的精力去做一些更有意义更有价值的事情。效率的提升，可以使你想做的事情快速落地，快速试错，快速迭代，更有生命力和活力，同时也才能更有竞争力。效率的提升需要多思考，多总结，多沉淀，多复用。站在巨人的肩膀上，复用可复用的劳动成果并不断的优化和创新。\n\n三、讲究方法\n同样是做一件事，方法有很多。\n比如先整体后局部，从内到外，由细到粗，由粗到细，由点到面，由面到点等。不同的方法，产生的影响也是不同的，即便最终都是完成了这件事。因为这里面有时间和机会成本在里面，考虑到时间和机会成本，当然是时间更短的胜出。但是也不是绝对，因为有句话叫做慢工出细活，意思是说不能太过于急躁，急于求成，应沉下心来把东西好好打磨，但这更多是是针对熟悉的事物和同等生产力的情况下，做的越细当然越好。针对不同的情况，应选择不同的方法，比如针对一个新事物，如果一下子考虑的面面俱到，很深很细，往往很难落地。因为复杂性和业务的多变性，充满太多的未知的不确定因素，往往容易让人知难而退，止步不前。俗话说万事开头难，难在迈出那一步。所以这时应当选取由粗到细的方法，先争取快速的实现业务，不要考虑的过深过细，毕竟有很多未知的变动的因素。得允许有试错和迭代的机会。否则，就是在失去先机。或许等面面俱到的实现了，也已经不再有大的价值和意义了。\n\n四、融入情怀\n\n俞敏洪说过一句话，名利和地位不是你一味的追求就能获得的，而是你坚持用心的做一件事，自然而然而来的。他就是如此，乔布斯亦是如此。之前有个访谈节目问乔布斯，为什么要创办苹果？为了钱吗？他笑了，说如果因为钱他根本没办法坚持，甚至投入精力。人，习惯于懒惰。人应该支配习惯，而决不能让习惯支配人。人的一生应该怎样的度过才有意义？《钢铁是怎样炼成的》中的保尔柯察金说：人，最宝贵的是生命，生命对于每个人只有一次。这仅有的一次生命应该怎样度过呢？每当回首往事的时候，不会因为虚度年华而悔恨，也不因碌碌无为而羞愧。\n\n网上有人说，\"俞敏洪这种公知还是算了，很多公知都有点问题，就是老想语不惊人死不休，但实际上放之四海而皆准的公理大家都懂，所以就开始搞些偷换概念的歪理，一听有点道理，一推敲就不是味儿。而且说乔布斯访谈的，估计乔布斯传都没看过，乔布斯二十出头就是亿万身家，当然不为了赚钱了，但我们是普通人。坚持做一件事真的很难，没钱就没法坚持了。\",但是话虽如此，如果没有兴趣爱好或情怀投入里面，真的能坚持吗，能做好吗？真的能挣钱吗？\n\n不是说要去崇拜谁，迷信谁，盲从谁。做好自己就行了。\n\n毕竟耳朵在自己身上，对了听，不对扔。仅此而已，一笑了之。\n\n有人说我的兴趣爱好就是打牌，打游戏。但是打游戏也有以此为职业的，这告诉我们最好是能稍微的把兴趣爱好同职业结合起来，实现个人的价值和对社会的贡献。虽然每个人对人生的意义理解不尽相同，但没准这样充实和做喜欢做的事，用心做事，不管结果如何，本身就是一种意义所在。这个社会每个人都少不了柴米油盐，少有谁能像诗仙李白那样的飘柔朗逸。但是先用心把事情做好，多少投入点儿兴趣和情怀，和你追求财富并不矛盾，并且是告诉我们一个道理，切莫因急功近利而变得浮躁沉不下心来认真做事，那样只会适得其反，欲速则不达。\n", "imgFile": "05.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 1}, "a90f8a4cfeb6471224bf8a3458f038b0": {"id": "a90f8a4cfeb6471224bf8a3458f038b0", "item": "感悟", "title": "张一鸣的感悟", "date": "2020-10-22", "summary": "2001年我考入了南开大学，起初大学的生活是让人有点失落的，但慢慢地从安静朴素的校园和踏实努力的氛围中，我还是找到了自己的节奏。大学期间我主要在做三件事情 ，一是写代码，因为我是搞技术的；二是看书，看了很多很多书；三是修电脑。基于此自己也有三点收获：耐心，知识，伙伴。", "body": "\n\n# 大学里的三点收获\n\n2001年我考入了南开大学，起初大学的生活是让人有点失落的，但慢慢地从安静朴素的校园和踏实努力的氛围中，我还是找到了自己的节奏。大学期间我主要在做三件事情 ，一是写代码，因为我是搞技术的；二是看书，看了很多很多书；三是修电脑。基于此自己也有三点收获：耐心，知识，伙伴。\n![Alt](/assets/images/20200609004.jpg)\n\n第一点收获：耐心。**有耐心，能独处，并基于长期思考做判断，而不为短期因素所干扰，耐心地等待你设想和努力的事情逐步发生，这对创业来说是非常重要的事情**。事实上，你经常想象的很美好，设计的也很完整，你也很努力，但你所期待的事情，经常需要很长时间才能发生。这种耐心，绝对是在南开磨练出来的。\n\n大学的时候我是怎么面对枯燥的生活？人物传记是非常好的心灵鸡汤。我读了很多人物传记，如果说有收获，就是发现那些伟大的人，在没有成为伟大的人之前，也是过着看起来枯燥的生活，每天都在做一些微不足道的事情，但这些事情最后从点连成线，成就了他们。\n\n我毕业后参与创立了酷讯、饭否、99房、到现在的今日头条，每一段创业经历，都挺寂寞的。**现在回想，耐心非常重要，不仅是等待的耐心，还要有耐心做深入思考，还要有耐心地找到更多更好的合作伙伴**。\n\n第二点收获：看书。寂寞的大学生活，给了我人生最安静的阅读时光。**我用别人打游戏、打牌的时间，阅读了各种各样的书，或者说乱七八糟的书，包括各个专业的书，包括人物传记，也有各种境内外的报刊杂志**。\n\n当然，那时候，我也有困惑，觉得看的这些东西和思考的问题都很有意思，**但在生活中没什么用。**直到后来我进入互联网行业并开始创业，**各种各样的知识才连成线，帮我理解行业、理解管理，更快地掌握不熟悉的领域，包括如何让信息得到更有效率的组织和分发，从而改变各行各业的效率**。\n\n2011年，我观察到一个现象，地铁上读报的人、卖报的人越来越少，年初还有，年底几乎没有了， 同时，2011年是智能手机出货量的高峰，是2008年、2009年、2010年三年智能手机出货量的总和。我想，这是信息传播介质的变革，手机很可能会取代纸媒成为信息传播的最主要载体，又因为人和手机的对应关系，手机随身携带，个性化推荐的需求一定会增加，于是我创办了今日头条。\n\n第三点收获：结交了很多的伙伴。我在读大学的时候结识了很多优秀的同伴。作为一个不怎么参与集体活动的理工男，怎么保持社交呢？主要靠修电脑和编程建网站……后来，同学聚会，打招呼的方式基本是：hi，你的电脑还是我装的。我装过的电脑有几十台，当然大部分是女同学……不但要帮忙装电脑还要经常保修。没错，就像你们想象的那样，修电脑为我带来了人生重大的收获——当时的女朋友，现在的太太。\n\n在校园里，我接了不少外包的项目。包括我太太她们系的网站(当然是免费的)。因为这门手艺加上兼职，大四的时候，我每月能有超过两三千的收入，在当时，绝对是土豪。那时候，和同学一起泡实验室，熬到半夜一两点，会请大家集体去烤串。一周能吃2-3次。\n\n当时和我吃烧烤的人很多是对编程感兴趣，而且志趣相投的同学朋友，有我同一级的，微电子专业的，软件工程专业的，还有师兄师弟，后来也相继加入我创办的公司，成为了我们公司的技术骨干，也是创业伙伴。\n\n# 我的工作感悟\n\n2005 年，我从南开大学毕业，加入一家叫酷讯的公司。我是最早期加入的员工之一，一开始只是一个普通工程师，但在工作第二年，我在公司管了四五十个人的团队，负责所有后端技术，同时也负责很多产品相关的工作。\n\n有人问我：为什么你在第一份工作中就成长很快？是不是你在那个公司表现特别突出？其实不是。当时公司招聘标准很高，跟我同期入职的就有两个清华计算机系的博士。那我是不是技术最好？是不是最有经验？都不是。后来我想了想，当时自己有哪些特质。\n\n首先，我工作时，**从不分哪些工作是我该做的，哪些不是我该做的**。我做完自己的工作后，对于大部分同事的问题，只要我能帮助解决，我都去做。当时，Code Base中大部分代码我都看过。新人入职时，只要我有时间，我都给他讲解一遍。通过讲解，我自己也能得到成长。\n\n工作的前两年，我基本上每天都是十二点、一点回家，回家后也编程到挺晚。**确实是因为有兴趣**，而不是公司有要求。所以我很快从负责一个抽取爬虫的模块，到负责整个后端系统，开始带一个小组，后来带一个小部门，再后来带一个大部门。\n\n当时我负责技术，但遇到产品上有问题，也会积极地参与讨论，想产品的方案。很多人说这个不是我该做的事情。但我想说：**你的责任心，希望把事情做好的动力，会驱动你做更多事情，让你得到很大的锻炼**。\n\n我当时是工程师，但参与产品的经历，对我后来转型做产品有很大帮助。我参与商业的部分，对我现在的工作也有很大帮助。记得在2007年底，我跟公司的销售总监一起去见客户。这段经历让我知道，怎样的销售才是好的销售。当我组建今日头条招人时，这些可供参考的案例，让我在这个领域不会一无所知。\n\n# 我的创业初心\n\n我很尊敬Elon Mask ，他不仅创办了TESLA ，而且还创办了一家叫Space X的公司，目标是革新太空科技，终极目标是人类能够在其他星球生活。\n\nSpace X现在是全世界第一家私人向太空发射火箭并实现回收的公司，尽管在前沿领域里不断探索的过程非常艰难，身后甚至连跟随者都没有，但Elon Mask一直相信：**只要理论上能够成立，理论上可以做到最好，那就应该去努力实现它**。\n\n我特别欣赏这种追求卓越和领先的勇气。年轻人创业，**就是要去创造新的技术，做那些理论上存在但还没有实现的东西，给世界带来根本性的进步**。创业，有人想的是要赚笔钱，有人想的则是**要做件事**，我觉得自己是后者。\n\n如果你偶然发现青霉素能消炎，你是先考虑用它去救人还是赚钱呢？应该都是先想到救人。我也是一样。到了这个时代，有个性化的方式来推荐信息，我就想把它做出来。\n\n如果我想卖掉这家公司，现在就可以拿到一大笔钱。但我奋斗的目标不是**赚钱和享乐，支撑我的是自我实现，希望有更多的创造体验，更丰富的人生经历，希望遇到更多优秀的人。**\n\n现在的创业环境和以前相比已经非常好了，创业能取得多大的成果，最重要的是，你到底愿意做多大的事情。年轻人关键是立志高远，享受拼的过程，不自满，不懈怠。要把成功的目标，设定的尽可能远。\n\n# 优秀年轻人的五个特点\n\n后来，我陆续加入到各种创业团队。在这个过程中，我跟很多毕业生共处过，现在还和他们很多人保持联系。跟你分享一下，我看到的一些好和不好的情况。总结一下，这些优秀年轻人有哪些特点呢？\n\n第一个特点：**有好奇心，能够主动学习新事物、新知识和新技能**。我有个前同事，理论基础挺好，但每次都是把自己的工作做完就下班了。\n\n他在这家公司呆了一年多，但对网上的新技术、新工具都不去了解，非常依赖别人，当他想要实现一个功能，就需要有人帮他做后半部分，因为他自己只能做前半部分。如果是有好奇心的人，前端、后端、算法都去掌握，至少有所了解的话，那么很多调试分析，自己一个人就可以做。\n\n第二个特点：**对不确定性保持乐观**。比方说，今日头条刚开始时，我跟大家讲：我们要做1亿的日启动次数，很多人觉得，你这家小公司怎么可能做得到呢？如果对此持怀疑态度，就不敢努力去尝试。**只有乐观的人会相信，会愿意去尝试**。\n\n其实我加入酷讯时也是这样，那家公司当时想做下一代搜索引擎（最后也没有做成，只做了旅游的垂直搜索）。我不知道其他人怎么想的，我自己觉得很兴奋。我确实没有把握，也不知道怎么做，但当时就去学，就去看所有相关的东西。我觉得最后也许不一定做成，或者没有完全做到，但这个过程也会很有帮助——**只要对事情的不确定性保持乐观，你会更愿意去尝试**。\n\n第三个特点：**不甘于平庸**。走入社会后的年轻人，应该设定更高的标准。大学期间的同学、一起共事的同事中，有很多非常不错的人才，技术、成绩都比我好，但10年过去了，很多人没有达到我当初的预期。\n\n很多人毕业后，目标设定就不高。我回顾了一下，发现有同事加入银行IT部门：有的是毕业后就加入，有的是工作一段时间后加入。为什么我把这个跟「不甘于平庸」挂在一起呢？因为他们很多人加入，是为了快点解决北京户口，或者得到买经济适用房的机会。\n\n如果一个人一毕业，就把目标定在这儿：在北京五环内买一个小两居、小三居，把精力都花在这上面，那么工作就会受到很大影响，他的行为会发生变化，不愿意冒风险。\n\n如果不甘于平庸，希望做得非常好的话，其实不会为这些东西担心，这很重要。我说不平庸，并不是专指薪酬要很高或者技术很好，而是你对自己的标准一定要高。也许你前两年变化得慢，但10年后再看，肯定会非常不一样。\n\n第四个特点：**不傲娇，要能延迟满足感**。在这里举个反例：两个我印象比较深刻的年轻人，素质、技术都蛮不错，也都挺有特点。我当时是他们的主管，发现他们在工作中deliver（传递）的感觉始终不好。\n\n他们觉得其他同事做得不如他们，其实不是：他们确实可以算作在当时招的同事里面 TOP20% ，但他们觉得自己是 TOP1% 。所以很多基础一点的工作，比如要做一个调试工具，他就不愿意做，或者需要跟同事配合的工作，他就配合得不好。\n\n本来都是资质非常好的人才，人非常聪明、动手能力也强，但没有控制好自己的傲娇情绪。我觉得这和「不甘于平庸」不矛盾。**「不甘于平庸」是你目标要设得很高，「不傲娇」是你对现状要踏实**。\n\n另一个例子是，当时我们有个做产品的同事，也是应届生招进来，当时大家都觉得他不算特别聪明，就让他做一些辅助性的工作，统计一下数据，做一下用户反弹之类，但现在他已经是一家十亿美金公司的副总裁。\n\n后来我想想，他的特点就是**肯去做，负责任，从不推诿，只要有机会承担的事情，他总尽可能地做好**。每次也不算做得特别好，但我们总是给他反馈。他去了那家公司后，把一个用户量不足 10 万的边缘频道负责起来，越做越好。由于是边缘频道，没有配备完整的团队，所以他一个人承担了很多职责，也得到了很多锻炼。\n\n第五个特点：**对重要的选择要有判断力**。选什么专业、选什么公司、选什么职业、选什么发展路径，自己要有判断力，不要被短期选择所左右。比如，原先有很多人愿意去外企，不愿意去新兴公司。\n\n2006 年、2007年的时候，很多师弟、师妹问我职业选择，我都建议他们去百度，不要去IBM、微软。但实际上，很多人都是出于短期考虑：外企可能名气大、薪酬高一点。虽然这个道理，大家都听过很多遍。刚毕业时薪酬差三五千块，真的可以忽略不计。短期薪酬差别并不重要。但实际上，能摆脱这个、能有判断力的人，也不是特别多。", "imgFile": "s2.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 1}, "146ceb48c4a2d34b8e2868192908d228": {"id": "146ceb48c4a2d34b8e2868192908d228", "item": "感悟", "title": "每个人的生命里都有一只碗", "date": "2020-09-22", "summary": "有一个年轻人去买碗，来到店里他顺手拿起一只碗，然后依次与其它碗轻轻碰击，碗与碗之间相碰时立即发出沉闷、浑浊的声响，他失望地摇摇头。 然后去试下一只碗……他几乎挑遍了店里所有的碗，竟然没有一只满意的，就连老板捧出的自认为是店里碗中精品也被他摇着头失望地放回去了。", "body": "有一个年轻人去买碗，来到店里他顺手拿起一只碗，然后依次与其它碗轻轻碰击，碗与碗之间相碰时立即发出沉闷、浑浊的声响，他失望地摇摇头。 然后去试下一只碗……他几乎挑遍了店里所有的碗，竟然没有一只满意的，就连老板捧出的自认为是店里碗中精品也被他摇着头失望地放回去了。\n老板很是纳闷，问他老是拿手中的这只碗去碰别的碗是什么意思？他得意地告诉老板，这是一位长者告诉他的挑碗的诀窍，当一只碗与另一只碗轻轻碰撞时，发出清脆、悦耳声响的，一定是只好碗。老板恍然大悟，拿起一只碗递给他，笑着说：“小伙子，你拿这只碗去试试，保管你能挑中自己心仪的碗”。\n他半信半疑地依言行事。奇怪！他手里拿着的每一只碗都在轻轻地碰撞下发出清脆的声响，他不明白这是怎么回事，惊问其详。\n老板笑着说，道理很简单，你刚才拿来试碗的那只碗本身就是一只次品，你用它试碗那声音必然浑浊，你想得到一只好碗，首先要保证自己拿的那只也是只好碗……\n就像一只碗与另一只碗的碰撞一样，一颗心与另一颗心的碰撞，需要付出真诚，才能发出清脆悦耳的响声。自己带着猜忌、怀疑甚至戒备之心与人相处，就难免得到别人的猜忌与怀疑。其实每个人都可能成为自己生命中的“贵人”，前提条件是，你应该与人为善。\n你付出了真诚，就会得到相应的信任，你献出爱心，就会得到尊重。反之，你对别人虚伪、猜忌甚至嫉恨，别人给你的也只能是一堵厚厚的墙和一颗冷漠的心。每个人的生命里都有一只碗，碗里盛着善良、信任、宽容、真诚，也盛着虚伪、狭隘、猜忌、自私……请剔除碗里的杂质，然后微笑着迎接另一只碗的碰撞，并发出你们清脆、爽朗的笑声吧！\n做最好的自己，才能碰见最好的别人。", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}, "0b4a8fb92680cdce7b468b27e9f39809": {"id": "0b4a8fb92680cdce7b468b27e9f39809", "item": "感悟", "title": "Second post!", "date": "2020-09-20", "summary": "你好aaaaaaaa！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。", "body": "\n\nThis is the main post!\n\n# Markdown1!\n## Markdown2!\n### 欢迎使用Markdown编辑器\n\nName    | Age\n--------|------\nBob     | 27\nAlice   | 23\n\n你好！ 这是你第一次使用 **Markdown编辑器** 所展示的欢迎页。如果你想学习如何使用Markdown编辑器, 可以仔细阅读这篇文章，了解一下Markdown的基本语法知识。\n\n```golang\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello \")\n}\n```\n", "imgFile": "04.jpg", "author": "yangyongzhen", "cmtCnt": 0, "visitCnt": 0}}}